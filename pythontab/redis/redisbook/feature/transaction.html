
<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->

<!-- Mirrored from docs.pythontab.com/redis/redisbook/feature/transaction.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 04 Oct 2022 03:57:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>事务 &mdash; Redis 设计与实现</title>
  
  
  
    
  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
  
   
  <script src="../_static/js/modernizr.min.js"></script>
</head>
<body class="wy-body-for-nav" role="document">
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index-2.html" class="icon icon-home"> Redis 设计与实现
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://docs.pythontab.com/redis/redisbook/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../internal-datastruct/sds.html">简单动态字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal-datastruct/adlist.html">双端链表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal-datastruct/dict.html">字典</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal-datastruct/skiplist.html">跳跃表</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../compress-datastruct/intset.html">整数集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compress-datastruct/ziplist.html">压缩列表</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../datatype/object.html">对象处理机制</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datatype/string.html">字符串</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datatype/hash.html">哈希表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datatype/list.html">列表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datatype/set.html">集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="../datatype/sorted_set.html">有序集</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">事务</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">事务</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">开始事务</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">命令入队</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">执行事务</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">在事务和非事务状态下执行命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discard-multi-watch">事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#watch">带 WATCH 的事务</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">WATCH 命令的实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">WATCH 的触发</a></li>
<li class="toctree-l2"><a class="reference internal" href="#acid">事务的 ACID 性质</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#atomicity">原子性（Atomicity）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#consistency">一致性（Consistency）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">入队错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">执行错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#redis">Redis 进程被终结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#isolation">隔离性（Isolation）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#durability">持久性（Durability）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pubsub.html">订阅与发布</a></li>
<li class="toctree-l1"><a class="reference internal" href="scripting.html">Lua 脚本</a></li>
<li class="toctree-l1"><a class="reference internal" href="slowlog.html">慢查询日志</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../internal/db.html">数据库</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/rdb.html">RDB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/aof.html">AOF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/ae.html">事件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internal/redis.html">服务器与客户端</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index-2.html">Redis 设计与实现</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index-2.html"> &mdash; Redis 设计与实现</a> &raquo;</li>
      
    <li>事务</li>
      <li class="wy-breadcrumbs-aside">
        
            <a href="../../../index.html" class="fa fa-github"> 在线手册中心</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>事务<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Redis 通过 <span class="xref std std-ref">MULTI</span> 、 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">EXEC</span> 和 <span class="xref std std-ref">WATCH</span> 四个命令来实现事务功能，
本章首先讨论使用 <span class="xref std std-ref">MULTI</span> 、 <span class="xref std std-ref">DISCARD</span> 和 <span class="xref std std-ref">EXEC</span> 三个命令实现的一般事务，
然后再来讨论带有 <span class="xref std std-ref">WATCH</span> 的事务的实现。</p>
<p>因为事务的安全性也非常重要，
所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p>
<div class="section" id="id2">
<h2>事务<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>事务提供了一种“将多个命令打包，
然后一次性、按顺序地执行”的机制，
并且事务在执行的期间不会主动中断 ——
服务器在执行完事务中的所有命令之后，
才会继续处理其他客户端的其他命令。</p>
<p>以下是一个事务的例子，
它先以 <span class="xref std std-ref">MULTI</span> 开始一个事务，
然后将多个命令入队到事务中，
最后由 <span class="xref std std-ref">EXEC</span> 命令触发事务，
一并执行事务中的所有命令：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s">&quot;C++&quot;</span> <span class="s">&quot;Programming&quot;</span> <span class="s">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="mi">1</span><span class="p">)</span> <span class="n">OK</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">3</span>
<span class="mi">4</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;Mastering Series&quot;</span>
   <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;C++&quot;</span>
   <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;Programming&quot;</span>
</pre></div>
</div>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol class="arabic simple">
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<p>下文将分别介绍事务的这三个阶段。</p>
</div>
<div class="section" id="id3">
<h2>开始事务<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p><span class="xref std std-ref">MULTI</span> 命令的执行标记着事务的开始：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>
</pre></div>
</div>
<p>这个命令唯一做的就是，
将客户端的 <code class="docutils literal"><span class="pre">REDIS_MULTI</span></code> 选项打开，
让客户端从非事务状态切换到事务状态。</p>
<p class="graphviz">
digraph normal_to_transaction {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];
}
</p>
</div>
<div class="section" id="id4">
<h2>命令入队<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>当客户端处于非事务状态下时，
所有发送给服务器端的命令都会立即被服务器执行：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello moto&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="s">&quot;hello moto&quot;</span>
</pre></div>
</div>
<p>但是，
当客户端进入事务状态之后，
服务器在收到来自客户端的命令时，
不会立即执行命令，
而是将这些命令全部放进一个事务队列里，
然后返回 <code class="docutils literal"><span class="pre">QUEUED</span></code> ，
表示命令已入队：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello moto&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>以下流程图展示了这一行为：</p>
<p class="graphviz">
digraph enqueue {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; enqueu_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}
</p>
<p>事务队列是一个数组，
每个数组项是都包含三个属性：</p>
<ol class="arabic simple">
<li>要执行的命令（cmd）。</li>
<li>命令的参数（argv）。</li>
<li>参数的个数（argc）。</li>
</ol>
<p>举个例子，
如果客户端执行以下命令：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s">&quot;C++&quot;</span> <span class="s">&quot;Programming&quot;</span> <span class="s">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>那么程序将为客户端创建以下事务队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="15%" />
<col width="58%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">cmd</th>
<th class="head">argv</th>
<th class="head">argc</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">SET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">GET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">SADD</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">SMEMBERS</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h2>执行事务<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>前面说到，
当客户端进入事务状态之后，
客户端发送的命令就会被放进事务队列里。</p>
<p>但其实并不是所有的命令都会被放进事务队列，
其中的例外就是 <span class="xref std std-ref">EXEC</span> 、 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">MULTI</span> 和 <span class="xref std std-ref">WATCH</span> 这四个命令 ——
当这四个命令从客户端发送到服务器时，
它们会像客户端处于非事务状态一样，
直接被服务器执行：</p>
<p class="graphviz">
digraph not_enque_command {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    not_exec_and_discard [label = &quot;命令是否\nEXEC 、 DISCARD 、\nMULTI 或 WATCH ？&quot;, shape = diamond, fillcolor = &quot;#FFC1C1&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; not_exec_and_discard [label = &quot;是&quot;];

    not_exec_and_discard -&gt; enqueu_command [label = &quot;否&quot;];

    not_exec_and_discard -&gt; exec_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}
</p>
<p>如果客户端正处于事务状态，
那么当 <span class="xref std std-ref">EXEC</span> 命令执行时，
服务器根据客户端所保存的事务队列，
以先进先出（FIFO）的方式执行事务队列中的命令：
最先入队的命令最先执行，
而最后入队的命令最后执行。</p>
<p>比如说，对于以下事务队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="15%" />
<col width="58%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">cmd</th>
<th class="head">argv</th>
<th class="head">argc</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">SET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">GET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">SADD</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">SMEMBERS</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
</tbody>
</table>
<p>程序会首先执行 <span class="xref std std-ref">SET</span> 命令，
然后执行 <span class="xref std std-ref">GET</span> 命令，
再然后执行 <span class="xref std std-ref">SADD</span> 命令，
最后执行 <span class="xref std std-ref">SMEMBERS</span> 命令。</p>
<p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="26%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">回复类型</th>
<th class="head">回复内容</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td>status code reply</td>
<td><code class="docutils literal"><span class="pre">OK</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td>bulk reply</td>
<td><code class="docutils literal"><span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td>integer reply</td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td>multi-bulk reply</td>
<td><code class="docutils literal"><span class="pre">[&quot;Mastering</span> <span class="pre">Series&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;]</span></code></td>
</tr>
</tbody>
</table>
<p>当事务队列里的所有命令被执行完之后，
<span class="xref std std-ref">EXEC</span> 命令会将回复队列作为自己的执行结果返回给客户端，
客户端从事务状态返回到非事务状态，
至此，
事务执行完毕。</p>
<p>事务的整个执行过程可以用以下伪代码表示：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">execute_transaction</span><span class="p">():</span>

    <span class="c"># 创建空白的回复队列</span>
    <span class="n">reply_queue</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># 取出事务队列里的所有命令、参数和参数数量</span>
    <span class="k">for</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span> <span class="ow">in</span> <span class="n">client</span><span class="o">.</span><span class="n">transaction_queue</span><span class="p">:</span>

        <span class="c"># 执行命令，并取得命令的返回值</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">execute_redis_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">)</span>

        <span class="c"># 将返回值追加到回复队列末尾</span>
        <span class="n">reply_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reply</span><span class="p">)</span>

    <span class="c"># 清除客户端的事务状态</span>
    <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c"># 清空事务队列</span>
    <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c"># 将事务的执行结果返回给客户端</span>
    <span class="n">send_reply_to_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">reply_queue</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>在事务和非事务状态下执行命令<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>无论在事务状态下，
还是在非事务状态下，
Redis 命令都由同一个函数执行，
所以它们共享很多服务器的一般设置，
比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p>
<p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p>
<ol class="arabic">
<li><p class="first">非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p>
<p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p>
</li>
<li><p class="first">在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p>
<p>而事务则是将所有命令的结果集合到回复队列，再作为 <span class="xref std std-ref">EXEC</span> 命令的结果返回给客户端。</p>
</li>
</ol>
</div>
<div class="section" id="discard-multi-watch">
<h2>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令<a class="headerlink" href="#discard-multi-watch" title="Permalink to this headline">¶</a></h2>
<p>除了 <span class="xref std std-ref">EXEC</span> 之外，
服务器在客户端处于事务状态时，
不加入到事务队列而直接执行的另外三个命令是 <span class="xref std std-ref">DISCARD</span> 、 <span class="xref std std-ref">MULTI</span> 和 <span class="xref std std-ref">WATCH</span> 。</p>
<p><span class="xref std std-ref">DISCARD</span> 命令用于取消一个事务，
它清空客户端的整个事务队列，
然后将客户端从事务状态调整回非事务状态，
最后返回字符串 <code class="docutils literal"><span class="pre">OK</span></code> 给客户端，
说明事务已被取消。</p>
<p>Redis 的事务是不可嵌套的，
当客户端已经处于事务状态，
而客户端又再向服务器发送 <span class="xref std std-ref">MULTI</span> 时，
服务器只是简单地向客户端发送一个错误，
然后继续等待其他命令的入队。
<span class="xref std std-ref">MULTI</span> 命令的发送不会造成整个事务失败，
也不会修改事务队列中已有的数据。</p>
<p><span class="xref std std-ref">WATCH</span> 只能在客户端进入事务状态之前执行，
在事务状态下发送 <span class="xref std std-ref">WATCH</span> 命令会引发一个错误，
但它不会造成整个事务失败，
也不会修改事务队列中已有的数据（和前面处理 <span class="xref std std-ref">MULTI</span> 的情况一样）。</p>
</div>
<div class="section" id="watch">
<h2>带 WATCH 的事务<a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h2>
<p><span class="xref std std-ref">WATCH</span> 命令用于在事务开始之前监视任意数量的键：
当调用 <span class="xref std std-ref">EXEC</span> 命令执行事务时，
如果任意一个被监视的键已经被其他客户端修改了，
那么整个事务不再执行，
直接返回失败。</p>
<p>以下示例展示了一个执行失败的事务例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">WATCH</span> <span class="n">name</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">name</span> <span class="n">peter</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>以下执行序列展示了上面的例子是如何失败的：</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="45%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">时间</th>
<th class="head">客户端 A</th>
<th class="head">客户端 B</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T1</td>
<td><code class="docutils literal"><span class="pre">WATCH</span> <span class="pre">name</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>T2</td>
<td><code class="docutils literal"><span class="pre">MULTI</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>T3</td>
<td><code class="docutils literal"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">peter</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>T4</td>
<td>&nbsp;</td>
<td><code class="docutils literal"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">john</span></code></td>
</tr>
<tr class="row-even"><td>T5</td>
<td><code class="docutils literal"><span class="pre">EXEC</span></code></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>在时间 T4 ，客户端 B 修改了 <code class="docutils literal"><span class="pre">name</span></code> 键的值，
当客户端 A 在 T5 执行 <span class="xref std std-ref">EXEC</span> 时，Redis 会发现 <code class="docutils literal"><span class="pre">name</span></code> 这个被监视的键已经被修改，
因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<p>下文就来介绍 <span class="xref std std-ref">WATCH</span> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p>
</div>
<div class="section" id="id7">
<h2>WATCH 命令的实现<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>在每个代表数据库的 <code class="docutils literal"><span class="pre">redis.h/redisDb</span></code> 结构类型中，
都保存了一个 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
字典的键是这个数据库被监视的键，
而字典的值则是一个链表，
链表中保存了所有监视这个键的客户端。</p>
<p>比如说，以下字典就展示了一个 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典的例子：</p>
<p class="graphviz">
digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}
</p>
<p>其中， 键 <code class="docutils literal"><span class="pre">key1</span></code> 正在被 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 三个客户端监视，
其他一些键也分别被其他别的客户端监视着。</p>
<p><span class="xref std std-ref">WATCH</span> 命令的作用，
就是将当前客户端和要监视的键在 <code class="docutils literal"><span class="pre">watched_keys</span></code> 中进行关联。</p>
<p>举个例子，
如果当前客户端为 <code class="docutils literal"><span class="pre">client10086</span></code> ，
那么当客户端执行 <code class="docutils literal"><span class="pre">WATCH</span> <span class="pre">key1</span> <span class="pre">key2</span></code> 时，
前面展示的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 将被修改成这个样子：</p>
<p class="graphviz">
digraph new_watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; client10086;
    client10086 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086_2 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; client10086_2;
    client10086_2 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}
</p>
<p>通过 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
如果程序想检查某个键是否被监视，
那么它只要检查字典中是否存在这个键即可；
如果程序要获取监视某个键的所有客户端，
那么只要取出键的值（一个链表），
然后对链表进行遍历即可。</p>
</div>
<div class="section" id="id8">
<h2>WATCH 的触发<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>在任何对数据库键空间（key space）进行修改的命令成功执行之后
（比如 <span class="xref std std-ref">FLUSHDB</span> 、 <span class="xref std std-ref">SET</span> 、 <span class="xref std std-ref">DEL</span> 、 <span class="xref std std-ref">LPUSH</span> 、 <span class="xref std std-ref">SADD</span> 、 <span class="xref std std-ref">ZREM</span> ，诸如此类），
<code class="docutils literal"><span class="pre">multi.c/touchWatchedKey</span></code> 函数都会被调用 ——
它检查数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
看是否有客户端在监视已经被命令修改的键，
如果有的话，
程序将所有监视这个/这些被修改键的客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开：</p>
<p class="graphviz">
digraph dirty_cas {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    dirty_cas [label = &quot;事务安全性\n已被破坏&quot;, fillcolor = &quot;#B22222&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];

    transaction -&gt; dirty_cas [label = &quot;打开选项\nREDIS_DIRTY_CAS&quot;];
}
</p>
<p>当客户端发送 <span class="xref std std-ref">EXEC</span> 命令、触发事务执行时，
服务器会对客户端的状态进行检查：</p>
<ul class="simple">
<li>如果客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li>
<li>如果 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li>
</ul>
<p>可以用一段伪代码来表示这个检查：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">check_safety_before_execute_trasaction</span><span class="p">():</span>

    <span class="k">if</span> <span class="n">client</span><span class="o">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">REDIS_DIRTY_CAS</span><span class="p">:</span>
        <span class="c"># 安全性已破坏，清除事务状态</span>
        <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c"># 清空事务队列</span>
        <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c"># 返回空回复给客户端</span>
        <span class="n">send_empty_reply</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># 安全性完好，执行事务</span>
        <span class="n">execute_transaction</span><span class="p">()</span>
</pre></div>
</div>
<p>举个例子，假设数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典如下图所示：</p>
<p class="graphviz">
digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}
</p>
<p>如果某个客户端对 <code class="docutils literal"><span class="pre">key1</span></code> 进行了修改（比如执行 <code class="docutils literal"><span class="pre">DEL</span> <span class="pre">key1</span></code> ），
那么所有监视 <code class="docutils literal"><span class="pre">key1</span></code> 的客户端，
包括 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项都会被打开，
当客户端 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 执行 <span class="xref std std-ref">EXEC</span> 的时候，
它们的事务都会以失败告终。</p>
<p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典中和这个客户端相关的资料都会被清除。</p>
</div>
<div class="section" id="acid">
<h2>事务的 ACID 性质<a class="headerlink" href="#acid" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">勘误：Redis 的事务是保证原子性的，本节的内容将原子性和回滚功能混淆了，等待修复中。 —— 2013.6.23</p>
</div>
<p>在传统的关系式数据库中，常常用 <a class="reference external" href="http://en.wikipedia.org/wiki/ACID">ACID 性质</a>来检验事务功能的安全性。</p>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<div class="section" id="atomicity">
<h3>原子性（Atomicity）<a class="headerlink" href="#atomicity" title="Permalink to this headline">¶</a></h3>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
</div>
<div class="section" id="consistency">
<h3>一致性（Consistency）<a class="headerlink" href="#consistency" title="Permalink to this headline">¶</a></h3>
<p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<div class="section" id="id10">
<h4>入队错误<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等，
那么服务器将向客户端返回一个出错信息，
并且将客户端的事务状态设为 <code class="docutils literal"><span class="pre">REDIS_DIRTY_EXEC</span></code> 。</p>
<p>当客户端执行 <span class="xref std std-ref">EXEC</span> 命令时，
Redis 会拒绝执行状态为 <code class="docutils literal"><span class="pre">REDIS_DIRTY_EXEC</span></code> 的事务，
并返回失败信息。</p>
<div class="highlight-c"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; MULTI
OK

redis 127.0.0.1:6379&gt; set key
(error) ERR wrong number of arguments for &#39;set&#39; command

redis 127.0.0.1:6379&gt; EXISTS key
QUEUED

redis 127.0.0.1:6379&gt; EXEC
(error) EXECABORT Transaction discarded because of previous errors.
</pre></div>
</div>
<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>
</div>
<div class="section" id="id11">
<h4>执行错误<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作，
那么 Redis 只会将错误包含在事务的结果中，
这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令，
所以它对事务的一致性也没有影响。</p>
</div>
<div class="section" id="redis">
<h4>Redis 进程被终结<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li><p class="first">内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>
</li>
<li><p class="first">RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>
</li>
<li><p class="first">AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>
<p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>
<p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="isolation">
<h3>隔离性（Isolation）<a class="headerlink" href="#isolation" title="Permalink to this headline">¶</a></h3>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
</div>
<div class="section" id="durability">
<h3>持久性（Durability）<a class="headerlink" href="#durability" title="Permalink to this headline">¶</a></h3>
<p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li><p class="first">在单纯的内存模式下，事务肯定是不持久的。</p>
</li>
<li><p class="first">在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>
</li>
<li><p class="first">在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code class="docutils literal"><span class="pre">fsync</span></code> 或 <code class="docutils literal"><span class="pre">fdatasync</span></code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="id12">
<h2>小结<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>带 <code class="docutils literal"><span class="pre">WATCH</span></code> 命令的事务会将客户端和被监视的键在数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开。</li>
<li>只有在客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li>
</ul>
</div>
</div>


           </div>
          </div>
	<hr/>
	<div>
		<p>扫码关注，获取更多内容</p>
		<img src="../../../statics/img/qrcode.jpg" width="100" height="100" />
	</div>
	<!-- duoshuo start -->
	<div class="ds-thread"></div>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"pytabdocs"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = '../../../statics/js/duoshuo.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
	</script>
	<!-- duoshuo end -->
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pubsub.html" class="btn btn-neutral float-right" title="订阅与发布" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../datatype/sorted_set.html" class="btn btn-neutral" title="有序集" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, huangz1990.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
  <script type="text/javascript" src="../../../static/js/global.html" ></script>
  <script type="text/javascript">
        var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
        document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F141f4ed9eb11f462fa19fdd960639134' type='text/javascript'%3E%3C/script%3E"));
  </script>
</body>

<!-- Mirrored from docs.pythontab.com/redis/redisbook/feature/transaction.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 04 Oct 2022 03:57:02 GMT -->
</html>